<p>Пете Булочкину крупно повезло: он, наконец, устроился на работу в фирму &quot;Macrohard&quot;.
Он хочет показать себя с самой лучшей стороны, поэтому к первому своему заданию
отнесся весьма ответственно. Задание состоит в том, чтобы написать поисковую
систему. Пете заранее известен набор чисел A1, A2, …, Ak ( 1&lt;=k&lt;=300,
1&lt;=Ai&lt;=10000000 , все Ai - различные целые числа) - назовем их ключами.
Система должна обрабатывать запросы типа: &quot;Содержится ли среди ключей
число s?&quot;. Известно, что число s может быть любым целым числом от 1 до n
(1&lt;=n&lt;=10000000). Руководство фирмы сказало Пете, что ему нужно
использовать как можно меньше памяти. Поразмыслив, Петя решил, что оптимальным
решением поставленной задачи будет использование двоичных деревьев поиска,
описание которых приведено ниже. </p>

<h3 class="cond_sect">$description$</h3>
<p>Двоичное дерево может быть пустым, или состоять из вершины, к которой
присоединены два двоичных дерева, то есть левое и правое поддерево (в этом случае
вершину, к которой присоединяются деревья, называют корнем). Если в каждую
вершину поместить по ключу, причем так, чтобы в разных вершинах были различные
ключи, то получим двоичное дерево для заданного набора ключей. Будем говорить,
что дерево является двоичным деревом поиска, если левое и правое поддеревья
являются двоичными деревьями поиска, а также любой ключ из левого поддерева,
выходящего из корня, меньше ключа, записанного в корне, а любой ключ из правого
поддерева - больше. </p>
<br>
<p>На рис. 1
показаны различные двоичные деревья для набора ключей 1, 3, 7, 11, из них
деревья б) и в) - двоичные деревья поиска. Корни деревьев изображены сверху.
Корни деревьев а) и б) - вершина с ключом 1, корень дерева в) - вершина с
ключом 7. </p>

<p align=center style='text-align:center'><img width=324 height=170 src="index.files/image001.gif"></p>

<p align=center style='text-align:center'>Рис. 1</p>
<br>
<p>Для того, чтобы проверить, содержится ли в заданном двоичном
дереве поиска ключ s, используется следующий алгоритм: </p>

<p>0) Положить текущую вершину равной корню дерева. </p>

<p>1) Проверить, совпадает ли s с ключом, записанным в текущей
вершине. Если да, то ключ s найден. Иначе перейти к шагу 2. </p>

<p>2) Если s меньше ключа, записанного в текущей вершине, то
положить текущую вершину равной корню левого поддерева, иначе - равной корню
правого поддерева (если соответствующие поддеревья отсутствуют, то алгоритм
заканчивает работу, выдавая, что ключ s в дереве отсутствует). Перейти к шагу
1. </p>

<br>
<p>Стоимостью поиска ключа s назовем количество выполненных
шагов 1) вышеописанного алгоритма. Например, для дерева на рис. 1в) стоимости
поиска различных ключей указаны в таблице: </p>

<div align=center>

<table class="tbdata" cellspacing=0 cellpadding=0>
 <tr>
  <th width=147 valign=top>Ключ</th>
  <td width=30 valign=top>1</td>
  <td width=30 valign=top>2</td>
  <td width=30 valign=top>3</td>
  <td width=30 valign=top>4</td>
  <td width=30 valign=top>5</td>
  <td width=30 valign=top>6</td>
  <td width=30 valign=top>7</td>
  <td width=30 valign=top>8</td>
  <td width=30 valign=top>9</td>
  <td width=38 valign=top>10</td>
  <td width=38 valign=top>11</td>
 </tr>
 <tr>
  <th width=147 valign=top>Стоимость поиска</th>
  <td width=30 valign=top>2</td>
  <td width=30 valign=top>3</td>
  <td width=30 valign=top>3</td>
  <td width=30 valign=top>3</td>
  <td width=30 valign=top>3</td>
  <td width=30 valign=top>3</td>
  <td width=30 valign=top>1</td>
  <td width=30 valign=top>2</td>
  <td width=30 valign=top>2</td>
  <td width=38 valign=top>2</td>
  <td width=38 valign=top>2</td>
 </tr>
</table>

</div>
<br>
<p>Стоимостью заданного двоичного дерева для диапазона поиска
от 1 до n назовем сумму стоимостей поиска каждого из ключей от 1 до n в этом
дереве. Например, стоимость дерева на рис. 1в) для диапазона поиска от 1 до 11
равна 26. </p>

<h3 class="cond_sect">$task$</h3> 
<p>Петя хочет построить для своей поисковой системы двоичное
дерево поиска минимальной стоимости. <br>
По введенным числам n, k, A1, …, Ak определить минимальную стоимость C
двоичного дерева поиска для набора ключей A1, A2, …, Ak и диапазона поиска от 1
до n. </p>

<h3 class="cond_sect">$input$</h3> 
<p>Входные данные состоят из k+2 строк: 1-я строка содержит
число n, 2-я строка - число k, строки с 3-й по (k+2)-ю - числа A1, .., Ak по
одному в строке. </p>

<h3 class="cond_sect">$output$</h3>
<p>Выходной файл должен содержать единственное число C. </p>

<h3 class="cond_sect">$sample$</h3>

<table class="tbdata" cellspacing=0 cellpadding=0 width="400">
 <tr><th width=96 valign=top>$input$</th><th width=108 valign=top>$output$</th></tr>
 <tr><td width=96 valign=top><pre>10
4
9
3
7
4</pre>
</td><td width=108 valign=top>22</td></tr>
</table>

<p>Оптимальным деревом для заданного примера будет следующее:</p>

<p><img width=324 height=170 src="index.files/image002.gif"></p>